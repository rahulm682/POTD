// https://practice.geeksforgeeks.org/problems/maximum-and-value-1587115620/1

// Given an array arr[] of N positive elements. The task is to find the Maximum AND Value generated by any pair(arri, arrj) from the array such that i != j.
//Note: AND is bitwise '&' operator.
//
//
//Example 1:
//
//Input:
//N = 4
//arr[] = {4, 8, 12, 16}
//Output: 8
//Explanation:
//Pair (8,12) has the Maximum AND Value 8.
//Example 2:
//
//Input:
//N = 4
//arr[] = {4, 8, 16, 2}
//Output: 0
//Explanation: Any two pairs of the array has
//Maximum AND Value 0.
//
//Your Task:
//You don't need to read input or print anything. Your task is to complete the function maxAND() which takes the array elements and N (size of the array) as input parameters and returns the maximum AND value generated by any pair in the array.
//
//Expected Time Complexity: O(N * log M), where M is the maximum element of the array.
//Expected Auxiliary Space: O(1).
//
//Constraints:
//1 <= N <= 105
//1 <= arr[i] <= 105

public class Day48_Q2 {
    public static void main(String[] args) {

    }



    // Function for finding maximum AND value.
    public static int maxAND (int arr[], int N) {
        // max possible value can be 10^5 and it can be represented using 18 bits in binary form
        // therefore we start from 1 followed by 17 0 bits

        // we would start from the MSB of the greatest possible ans as our answer
        // if it is possible to make the ans then set the current bit in the answer
        // now check for the further value i.e. if it is possible to make the next bits set or not
        // update the answer likewise


        // current ans
        int ans = 0;

        for(int i=17;i>=0;i--) {
            // let the temp ans be ans | (i<<i) ==> this could be our answer
            int x = ans | (1<<i);

            // if we can make the temp answer as our answer
            // update the answer
            // else do nothing
            // here whenever the first value that can be generated is found
            // we get the ans like 1 followed by some 0's

            // and after this is setting the next bit and check if it is possible to make the answer
            // we update the answer as 11 followed by zeros
            // else our answer remains 10 followed by 0's
            // these followed zeros are coming from when we set the 1st bit of our answer

            // lly, we do checking for all the bits and the answer obtained will be our answer
            if(isPossible(arr, x)) {
                ans = x;
            }
        }

        return ans;
    }

    static boolean isPossible(int[] arr, int x) {
        int cnt = 0;

        for(int y:arr) {
            if((y&x)==x) cnt++;

            if(cnt==2) return true;
        }

        return false;
    }
}
